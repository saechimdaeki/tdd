# TDD 기능 명세 설계

## 기능 명세

개발자는 코드를 작성하고 빌드하여 이를 사용자가 사용할 수 있게 배포한다. 사용자는 배포한 소프트웨어를 이용해서 원하는 기능을 실행한다. 우리가 코드를 작성하는 이유는 사용자

가 사용할 어떤 기능을 제공하기 위함이다. 기능에 대한 명세는 다양한 형태로 존재한다. 파워포인트를 이용한 스토리보드 형태도 있고 이메일과 같은 간단한 문장 형태도 있다.

어떤 형태가 되든 간에 사용자에게 제공할 기느을 구현하려면 기능을 크게 두가지로 나누어 생각해 볼 수 있다. 그것은 바로 입력과 결과다. 예를들어 로그인 기능을 생각해보자.

로그인 기능에서 입력과 결과는 다음과 같이 정의할 수 있다.

- 입력: 아이디와 암호
- 결과: 아이디와 암호가 일치하면 성공, 일치하지 않으면 실패

입력은 기능을 실행하는데 필요한 값이다. 로그인 기능을 실행하는데 필요한 것은 아이디와 암호이므로 이 두가지가 로그인 기능의 입력이 된다.

로그인 기능의 결과는 성공 또는 실패이다. 3장에서 살펴본 만료일 계산 기능의 경우에서 입력과 결과는 다음과 같다

- 입력: 첫 납부일, 납부일, 납부액
- 결과: 만료일 

입력은 보통 메소드의 파라미터로 전달한다. 만료일 계싼 기능은 필요한 값을 파라미터로 전달 받았다.

```java
// payData 인자: 만료일 계산 기능의 입력
// 리턴 값: 만료일 계산 기능의 결과
LocalDate realExpiryDate = cal.calculateExpiryDate(payData);
```

결과는 여러 형식으로 정의할 수 있다. 가장 쉽게 생각할 수 있는 결과 형식은 리턴 값이다. 만료일 계산 기능은 결과로 리턴 값을 사용했다. 익셉션을 결과로 사용할 수도 있다.

예를 들어 로그인 기능을 구현할 때 인증에 실패하면 IdPwNotMatchException을 발생할 수 있다.

```java
public void login(String id, String pw){
  User user=getUser(id);
  if(!user.matchPassword(pw)){
    //익셉션을 결과로 사용
    throw new IdPwNotMatchException();
  }
  ...;
}
```

기능 실행 결과에는 변경도 포함한다. 예를 들어 회원 가입 기능은 실행 결과로 DB에 회원 정보를 추가한다. DB에 데이터를 추가하는 것은 값을 리턴하는 것과 달리 시스템의 상태를

변경한다. 이런 변경은 리턴 값으로는 결과를 알 수 없기 때문에 테스트 대상을 실행한 뒤에는 변경 대상에 접근해서 결과를 확인해야 한다.

결과는 상황에 따라 달라질 수 있다. 아래의 그림은 회원 가입 기능의 결과를 정리한 예이다.

![image](https://user-images.githubusercontent.com/40031858/135001476-cecc7a5f-5953-49c0-9b85-0d378d2cb6c4.png)

회원 가입 기능은 상황에 따라 다른 결과를 갖는다. 이미 동일한 ID가 존재하는 상황에서는 결과로 익셉션을 발생한다. 동일한 ID가 존재하지 않은 상황에서는 가입에 성공하면

결과로 회원 일련번호를 리턴하고 정보를 DB에 저장한다.

설계는 기능 명세로부터 시작한다. 스토리보드를 포함한 다양한 형태의 요구사항 문서를 이용해서 기능 명세를 구체화한다. 기능 명세를 구체화하는 동안 입력과 결과를 도출하고

이렇게 도출한 기능 명세를 코드에 반영한다. 기능 명세의 입력과 결과를 코드에 반영하는 과정에서 기능의 이름, 파라미터, 리턴타입 등이 결정된다. 이는 곧 기능에 대한 설계과정과연결

## 설계 과정을 지원하는 TDD

TDD는 테스트를 만드는 것부터 시작한다. 테스트코드를 먼저 만들고 테스트를 통과시키기 위해 코드를 구현하고 리팩토링하는 과정을 반복한다. 여기서 중요한 것은 테스트 코드를

가장 먼저 작성해야 한다는 점이다. 테스트 코드를 먼저 만들기 위해 무엇이 필요할까? 여러가지가 있겠지만 그중에서도 다음 두가지를 할 수 있어야 한다

- 테스트할 기능을 실행
- 실행 결과를 검증

먼저 기능을 실행할 수 없으면 테스트를 할 수 없다. 테스트는 기능을 실행한 결과를 검증하는 것이므로 테스트 코드에서 기능을 실행할 수 있어야 한다. 즉 테스트에서 실행할 수 있는

객체나 함수가 존재해야 한다. 

실행할 객체가 존재하려면 객체를 생성할 때 사용할 클래스가 필요하고 실행할 메소드도 필요하다. 다시 말해 테스트 대상이 되는 클래스와 메소드의 이름을 결정해야 한다.

또한 메소드를 실행할때 사용할 인자의 타입과 개수를 결정해야한다.

![image](https://user-images.githubusercontent.com/40031858/135002006-5caf11aa-4a4c-4fd3-bbbd-b35885b65a89.png)

2장에서 살펴본 암호 강도 검사 예에서도 테스트를 작성하기 위해 가장 먼저 고민한 것은 테스트 클래스 이름이였다. PasswordLevel과 PasswordStrength 중에서 암호 강도를

뜻하는 PasswordStrength를 선택했다. Checker와 Meter 중에서 측정한다는 뜻을 갖는 Meter를 선택했다.

```java
public class PasswordStrengthMeterTest{
}
```

테스트 대상이 되는 타입의 이름을 결정한 뒤에는 테스트 코드에서 호출할 메소드를 고민했다. 2장에서는 측정한다는 뜻을 가진 meter를 메소드 이름으로 선택했고 암호는 문자열

이므로 파라미터로 String타입을 선택했다

```java
PasswordStrengthMeter meter = new PasswordStrengthMeter();
//테스트 코드에서 실행할 메소드의 이름과 파라미터를 결정
값타입 결과 = meter.meter("ab12!@AB");
```

테스트는 기능이 올바르게 동작하는지 검증하는 것이므로 실행 결과를 검증해야 한다. 이를 위해 실행 결과를 어떻게 검증할 수 있는지 고민해야 한다. 암호 검사 기능에서는

meter() 메소드의 리턴 값을 이용해서 검증하므로 이 메소드의 리턴 타입을 고민했다. 단순히 0,1,2와 같은 int타입을 사용해서 암호 강도를 표현할지 아니면 PasswordStrength와

같은 열거 타입을 이용해서 암호 강도를 표현할지 고민했다. 2장에서는 열거 타입을 이용해서 암호 강도를 표현하기로 결정했고, 이 열거 타입을 이용해서 기능이 올바르게

동작하는지 검증했다.

```java
//결과를 검증하는 방법을 고민하는 과정에서 리턴 타입을 결정
PasswordStrength result=meter.meter("ab12!@AB");
assertEquals(PasswordStrength.STRONG,result);
```

3장의 만료일 계산 기능도 유사한 과정을 거쳤다. 만료일 계산 기능을 의미하는 이름을 사용해서 클래스와 메소드 이름을 정했다. 만료일 계산에 필요한 입력을 전달하기 위해 파라미터를

결정했고 계산된 만료일을 검증하기 위해 리턴타입을 결정했다. 암호 강도 측정과 만료일 계산 예제는 테스트 코드를 작성하는 과정에서 다음 네가지를 결정했다

- 클래스 이름
- 메소드 이름
- 메소드 파라미터
- 실행 결과

이 네가지를 결정하는 과정에서 이름을 고민하고 파라미터 타입과 리턴 타입을 고민했다. 이는 곧 설계 과정이다. 타입의 이름을 정의하고 타입이 제공할 기능을 결정하는 것은 기본적인

설계 행위이다. 이 과정에서 타입이 제공할 기능을 실행하는데 필요한 값과 결과가 무엇인지 고민한다. TDD에서 테스트 코드를 작성할 때 고민하는 것과 설계 과정에서 고민하는 것은

겹치는 부분이 있음을 알 수 있다. 즉 TDD 자체가 설계는 아니지만, TDD를 하다보면 테스트 코드를 작성하는 과정에서 일부 설계를 진행하게 된다

## 필요한 만큼 설계하기

TDD는 테스트를 통과할 만큼만 코드를 작성한다. 필요할 것으로 예측해서 미리 코드를 만들지는 않는다. 이는 설계에도 동일하게 적용된다. 필요할 것으로 예측해서 미리 설계를

유연하게 만들지 않는다. 실제 테스트 사례를 추가하고 통과시키는 과정에서 필요한 만큼 설계를 변경한다. 

만료일 계산 예를 보자. 처음 만든 테스트에서 만료일 계산에 필요한 입력은 납부일과 납부액 이었다. 필요한 값이 두개이므로 다음 코드처럼 납부일과 납부액을 각각 파라미터로

전달받았다.

```java
//최초 설계는 두 개의 파라미터를 사용
LocalDate expiryDate = cal.calculateExpiryDate(billingDate, payAmount);
```

테스트 사례를 추가하는 과정에서 만료일을 계산하는데 첫 납부일을 사용하게 됐다. 이를 반영하기 위해 납부일, 납부액, 첫 납부일을 담는 타입을 새로 만들었다.

```java
//테스트를 진행하는 과정에서 필요한 만큼 설계 변경
PayData payData = PayData.builder()
  	.firstBillingDate(LocalDate.of(2019,1,31))
  	.billingDate(LocalDate.of(2019,2,28))
  	.payAmount(10_000)
  	.build();

LocalDate expiryDate = cal.calculateExpiryDate(payData);
```

기능 실행 결과도 동일하다. 미리 앞서서 필요해 보이는 익셉션 타입을 만들지 않는다. 테스트를 진행하는 과정에서 실제 익셉션이 필요한 시점에 익셉션을 도출한다. 

예를 들어 중복된 ID가 존재하는 경우 회원 가입에 실패하는 테스트를 추가하는 시점에 비로소 DupIdException 타입을 추가한다.

TDD로 개발을 진행하면 현 시점에서 테스트를 통과시키는데 필요한 만큼의 코드만 만들게 된다. 물론 모든 코드에 대해 테스트를 먼저 작성할 수는 없겠지만 TDD로 개발하는

코드 비율이 높아질수록 지금 시점에서 필요한 설계만 코드에 반영할 가능성이 커진다. 유연한 설계는 필요한 시점에 추가한다. 이를 통해 설계가 불필요하게 복잡해지는 것을

방지할 수 있다. TDD로 개발할 때 필요한 만큼만 설계를 한다고 해서 사전에 설계활동을 생략하는 것은 아니다. 요구사항을 분석하느 과정에서 설계를 진행한다. 단 이때 

결과물은 초안에 불과하다. 이 초안대로 처음부터 끝까지 개발된다는 보장은 없다. 최초 요구사항은 시간이 지나면 변하기 때문이다. 요구사항이 바뀌므로 처음에 필요하다고

생각했던 설계 요소가 구현 과정에서 쓸모가 없어지기도 하고 반대로 처음에 예상하지 못했던 설계 요소가 나중에 출현하기도 한다. TDD는 미리 앞서서

코드를 만들지 않으므로 불필요한 구성요소를 덜 만들게 된다.

## 기능 명세 구체화

테스트 코드를 작성하기 위해 개발자는 기능 명세를 정리해야 한다. 보통 개발자는 기획자가 작성한 스토리보드나 와이어프레임과 같은 형태로 요구사항 명세를 전달받는다. 이런 문서

는 사용자나 기획자가 보기에는 적당할지 모르나 개발자가 기능을 구현하기에는 생략된 내용이 많다.

테스트 코드를 작성하려면 파라미터와 결과 값을 정해야 하므로 개발자는 요구사항 문서에서 기능의 입력과 결과를 도출해야 한다. 또한, 다양한 테스트 사례를 추가하는 과정에서

구현하기 애매한 점을 발견해게 된다. 테스트 코드를 작성하려면 입력과 결과가 명확해야 하므로 애매한 점을 발견하면 기획자나 실무 담당자와 얘기해서 상황에 따라 기능이 어떻게

동작해야 하는지 구체적으로 정리해야 한다. 테스트 코드는 구체적인 입력과 결과를 이용해서 작성하므로 개발자는 예를 통해 기능 명세를 구체화하게 된다.

만료일 계산 기능을 예로 들어보자. 요구사항은 다음과 같았다

- 서비스를 사용하려면 매달 1만원을 선불로 납부한다. 납부일 기준으로 한 달 뒤가 서비스 만료일이 된다
- 2개월 이상 요금을 납부할 수 있다
- 10만원을 납부하면 서비스를 1년 제공한다

```java
		@Test
    void 납부일과_한달_뒤_일자가_같지_않음(){
        assertExpiryDate(PayData.builder()
                .billingDate(LocalDate.of(2019,1,31))
                .payAmount(10_000)
                .build(), LocalDate.of(2019,2,28));
        assertExpiryDate(PayData.builder()
                .billingDate(LocalDate.of(2019,5,31))
                .payAmount(10_000)
                .build(), LocalDate.of(2019,6,30));
        assertExpiryDate(PayData.builder()
                .billingDate(LocalDate.of(2020,1,31))
                .payAmount(10_000)
                .build(), LocalDate.of(2020,2,29));
    }
```

계속 테스트 사례를 추가하는 과정에서 다음과 같이 첫 납부일에 따라 만료일이 다른 상황을 구체화 했다.

```java
		@Test
    void 첫_납부일과_만료일_일자가_다를때_이만원_이상_납부(){
        assertExpiryDate(
                PayData.builder()
                        .firstBillingDate(LocalDate.of(2019,1,31))
                        .billingDate(LocalDate.of(2019,2,28))
                        .payAmount(20_000)
                        .build(),
                LocalDate.of(2019,4,30)
                );
    }
```

모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영한다. 즉 테스트 코드는 예를 이용한 구체적인 명세가 된다. 구체적인 예는 개발자가 요구사항을 더 잘 이해할수있게

만든다. 서비스 만료일도 요구사항만 보면 어떻게 구현해야 할지 애매한 상황이 많다. 구체적인 예는 이런 모호함을 없애주어 개발자가 올바르게 동작하는 기능을 만들 수 있게한다.

또한, 테스트 코드는 바로 실행할 수 있다. 테스트 코드를 이용하면 구체적인 예를 이용해서 기능을 바로 실행해 볼 수 있다. 이는 유지보수에 큰 도움이 된다. 

특정 상황에서 코드가 어떻게 동작하는지 이해하고 싶다면 해당 상황을 검증하는 테스트를 실행하고 이해가 필요한 코드를 추적하면 된다. 디버거를 이용해서 추적할 수 있고

콘솔에 출력되는 로그를 보면서 이해를 높일 수 있다.

